直接插入排序（插入类）：
    第 i 趟循环能保证前 i 个序列局部有序。稳定。除了适用于顺序存储，也适用于链式存储。为链式存储时，可以从前往后查找元素的位置。

折半排序（插入类）：
    基于直接插入排序，稳定，适合关键字数较多的场景，相对于直接插入排序，进一步减少了比较的次数。

直接选择排序（选择类）：
    第 i 趟循环能保证前 i 个序列有序，且都在最终位置。但不稳定。

冒泡排序（交换类）：
    每次循环结束能保证后 i 个序列全局有序，即有序且都在最终位置。稳定。

以上都是平均时间复杂为 O(n^2) 的排序方法。其中，只有直接选择排序的最好时间复杂度和最差时间复杂度相同，都是O(n^2)。
另外，所有算法空间复杂度均为O(1)。
——————————————————————————————————————————————————————

希尔排序（插入类）：
    基于直接插入排序，不稳定，时间复杂度我不好说，考试应该写 O(nlog2_n)。空间复杂度为O(1)。
    有经验的程序员有时会选择希尔排序，因为对于中等大小的数组它的运行时间是可以接受的。
    它的代码量很小，且不需要使用额外的内存空间。虽然有更加高效的算法，但除了对于很大的 N，它们可能只会比希尔排序
    快两倍(可能还达不到)，而且更复杂。如果你需要解决一个排序问题而又没有系统排序函数可用
    （例如直接接触硬件或是运行于嵌入式系统中的代码），可以先用希尔排序，
    然后再考虑是否值得将它替换为更加复杂的排序算法。
    ————————————————
    版权声明：本文为CSDN博主「我要看一下山顶的风景」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
    原文链接：https://blog.csdn.net/qq_34589749/article/details/104022624
——————————————————————————————————————————————————————
堆排序（选择类）：
    不稳定。堆排序在最差情况下的时间复杂度也是 O(nlog2_n)，这是它相对于快速排序的最大优点。
    堆排序的空间复杂度是 O(1)，在所有时间复杂度为 O(nlog2_n)的排序中是最小的，这也是一大优点。
    堆排序适合的场景是关键字很多时选几个最大或最小，典型的例子是从 10000 个关键字里选出前 10 个最小的，这种情况用堆排序更好。
    此外，每次循环也可以令一个关键字到达最终位置（完全替换了上文直接选择排序）。

快速排序（交换类）：
    不稳定。待排序列越接近无序，本算法效率越高。最好情况为 O(nlog2_n)，最坏情况为 O(n^2)。空间复杂度类似时间复杂度。
    在同级别的算法中（nlog2_n）级别，基本操作执行次数多项式为 X * nlog2_n，快速排序的 X 最小，即最好。目前认为快排是最好的内部排序方法。

——————————————————————————————————————————————————————————

基数排序：
    稳定，最坏情况和最好情况的时间复杂度一样。都是 O(maxLen * (n + RADIX))。时间复杂度为O(RADIX)
    基数排序适合的场景是序列中的关键字很多，但组成关键字的关键位数的取值范围（即基数）较小，如数字 0~9 都是可以接受的。
    如果关键字的取值范围也很大，如 26 个字母，并且序列中大多数关键字的最高位关键字都不相同，那么这时可以考虑使用
    最高位优先法，现根据最高位排成若干子序列，然后分别对这些子序列进行直接插入排序。（不懂，天勤书写的）

2-路归排序：
    稳定，最坏情况和最好情况的时间复杂度一样。都是 O(nlog(2_n))。时间复杂度为O(n)。
    归并排序可以作为外部排序方法，对大量数据排序。如对10TB的数据文件进行排序。
—————————————————————————————————————————————————————————————

综上，平均时间复杂度在O(n^2)以下的算法，除了基数排序外的平均时间复杂度均为 O(nlog2_n)。
且除了快速排序的最差时间复杂度为O(n^2)外，其它算法的最坏情况和最好情况的时间复杂度都为O(nlog2_n)。
至于空间复杂度，归并排序为 O(n)，最大，快速排序为 O(log2_n)，基数排序为 O(RADIX)，堆排序为 O(1)。

关键字比较次数与初始序列"无关"（仅与元素个数n有关）的排序方法为：简单选择排序和折半插入排序。（基数排序不需要比较关键字）
"排序趟数"和初始序列"有关"的排序方法为：交换类的冒泡排序（看flag啥时候为0）、快速排序（O(log2_n)次到O(n)次)。
每次能保证一个关键字到达最终位置的排序方法为：选择类的堆排序、直接选择排序。交换类的冒泡排序、快速排序。
关于前 i 个元素有序：
    有直接插入排序（插入类）、直接选择排序（选择类）、冒泡排序（交换类）、堆排序（选择类）：
    令前 i 个元素有序时，有如下区别：
        直接插入排序前 i 个元素序列有序但不在最终位置，平均为 O(n^2)
        直接选择排序前 i 个元素序列有序且在最终位置，平均为 O(n^2)
        冒泡排序前 i 个元素序列有序且在最终位置，平均为 O(n^2)
        堆排序前 i 个元素序列有序且在最终位置，执行次数为建堆 + i 次处理堆，即 O(n) + log2_n * i 具体推导见 https://www.zhihu.com/question/20729324
        快速排序有 i 个元素在最终位置，但整体不一定有序，是第 i 个元素左边都比它小，右边都比它大。平均为 O(nlog_2(n))
    关于冒泡排序和直接选择排序的时间复杂度这个答案跟我的想法基本一致：
        这两个算法思想上是一样的，确实容易混淆，每一轮冒泡从结果看，等价于从待排序序列中选择一个最小（大）的数放在
        特定位置，这与选择排序是一样的。
        不同之处在于，选择排序指交换两个元素时并不影响其他元素的相邻位置，而冒泡排序在交换过程中会改变其他元素的相邻位置。
        选择排序是与输入无关的，每次选择都要遍历待排序序列，而冒泡排序与输入有关，如果一轮遍历没有元素交换，就可以断定
        序列已经有序，即可以提前结束。具体取决于待排序序列的部分有序程度。
        原文链接：https://zhuanlan.zhihu.com/p/137220037
    所以如果要求前 i 个有序且在最终位置，可以使用直接选择排序、冒泡排序、堆排序，注意只有冒泡排序是稳定的，而
    直接选择排序、堆排序都是不稳定的，所以如果要求稳定只能使用
    冒泡排序。如果不要求稳定，当关键字很多时，
    堆排序效果最好。如果不要求有序，那还能加上一个快速排序。
    而如果只要求有序，不要求在最终位置，可以选择直接插入排序。

不稳定的排序方法为：选择类的堆排序、直接选择排序（都有无脑交换的地方）。插入类的希尔排序。交换类的快速排序。

若n较小，可采用直接插入排序或简单选择排序。因为直接插入排序的移动次数比简单选择排序多，所以当记录本身信息量较大时
或要求移动（交换）次数更少时，用简单选择排序较好。
若文件初始状态已基本有序，用直接插入或冒泡排序为宜。
若n较大，使用时间复杂度为O(nlog2_n)的排序方法。若要求稳定，只能用归并排序。
若n较大，且关键字位数较少且可以分解（0，1，2），采用基数排序较好。
当记录信息量本身较大时，为避免耗费大量时间移动，可用链表作为存储结构。